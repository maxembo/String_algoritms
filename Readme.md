1. Алгоритм массив граней.

Массив граней — это массив, который используется для хранения длины наибольшего граневого префикса строки для каждого индекса. Граневой префикс строки — это префикс строки, который одновременно является суффиксом (за исключением всей строки).


Инициализация переменных:
n - длина строки s;
bp - массив граней длиной n, инициализированный нулями.

Проходим по строке s начиная со второго символа.
Начинаем с i=1 до n

Сравниваем символы с предыдущими символами, используя переменную bp_right, которая инициализируется значением из предыдущего элемента массива bp.
Ищем наибольший граневой префикс для текущего символа, двигаясь к началу строки и сравнивая символы.
Если находит граневой префикс, обновляет bp[i] значением bp_right + 1.
Если не находит, bp[i] остается равным 0.
Обновляем bp_right и продолжаем искать грани.
Если символы не совпадают и bp_right == 0, bp[i] остается 0.
Возвращаем массив граней bp.

2. Алгоритм Кнута-Морриса-Пратта.

Алгоритм Кнута-Морриса-Пратта (KMP) — это алгоритм поиска подстроки в строке. Он использует информацию о том, какие символы уже сравнивались, чтобы избежать повторных сравнений в будущем.

Префикс-функция для строки t вычисляется следующим образом:

p[0]=0 (первый элемент всегда равен 0).
p[i] для i>0 вычисляется как максимальная длина суффикса подстроки t[0:i], который также является её префиксом.

Импортируем функцию prefix_border_array из модуля task1_Border_array.
Задаем строки a и t для поиска подстроки t в строке a.
Вычисляем префикс-функцию для строки t и сохраняем её в переменную prefix_array.
Определяем функцию kmp, которая реализует алгоритм КМП.
Инициализируем переменные i и j для индексов в строках a и t соответственно.
Внутри цикла while проверяем, совпадают ли символы a[i] и t[j].
Если совпадают, увеличиваем i и j на 1.
Если j достигает длины t, это значит, что образ t найден в строке a, и мы возвращаем True.
Если символы не совпадают и j не равно 0, то сдвигаем j на значение p[j-1].
Если j равно 0, просто увеличиваем i.
Если i достигает длины a, это значит, что образ t не найден в строке a, и мы возвращаем False.
Выводим результаты: исходные строки, префикс-функцию и результат выполнения функции kmp.

3. Алгоритм Бойера-Мура.

Алгоритм Бойера-Мура — это алгоритм поиска подстроки в строке. Он работает быстрее в большинстве случаев, чем стандартные алгоритмы поиска подстроки.

Создание словаря d, в котором ключи — это символы из шаблона t, а значения — это расстояния от конца t до последнего вхождения этого символа.
Если символ встречается несколько раз в шаблоне, берется расстояние до последнего вхождения.
Если символ не встречается в шаблоне, расстояние до конца шаблона M сохраняется в словаре.

Поиск подстроки в строке a:
Если длина строки a больше или равна длине шаблона t, начнем поиск с последнего символа шаблона.
Пока не достигнем начала строки a или не найдем шаблон:
Сравниваем символы шаблона с символами строки, начиная с конца шаблона.
Если символы не совпадают:
Используем словарь d, чтобы определить смещение, на которое можно передвинуть шаблон.
Передвигаем шаблон на это смещение.
Если все символы шаблона совпадают, подстрока найдена.

4. Алгоритм Карпа-Рабина

Алгоритм Карпа-Рабина является одним из методов поиска подстроки в строке, который использует хэширование для ускорения процесса поиска. 

Задаем два параметра B и Q. B - это база, Q - это модуль.
Вычисляем хэш для искомого паттерна с помощью функции get_hash().
Вычисляем хэш для первого фрагмента текста длиной pattern_len с помощью функции get_hash().
Сравниваем хэши. Если хэши совпадают, то проводим дополнительную проверку символов, чтобы убедиться в совпадении паттерна и фрагмента текста.
Если хэши не совпадают, вычисляем хэш следующего фрагмента текста, используя предыдущий хэш и двигаясь на один символ вправо.
Продолжаем сравнивать хэши и сдвигать окно поиска до тех пор, пока не пройдем весь текст.

5. Алгоритм Shift-And

Алгоритм Shift-And — это эффективный метод для поиска подстроки в строке. Он основан на битовых операциях и работает за время O(n), где n — длина строки.

Создаем словарь b, в котором ключами являются символы из строки p, а начальные значения — нули. Переменные l и tl содержат длины строки p и text соответственно.
Устанавливаем битовую маску для каждого символа в строке p. Битовая маска представляет собой число, в котором только один бит установлен в положение, соответствующее позиции символа в строке p.
Переменная d используется для хранения текущего состояния совпадения. Маска совпадения match_mask используется для определения того, произошло ли совпадение.
В цикле обходим каждый символ в строке text, обновляя значение переменной d с использованием битовых операций. Если в какой-то момент matched становится ненулевым, это означает, что образец найден в строке text, и мы возвращаем позицию начала образца.
Если образец не найден в строке text, функция возвращает -1.
В примере образец "abra" найден в строке "adracadabra", и функция возвращает позицию начала образца, то есть 7.
